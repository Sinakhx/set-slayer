var a=Object.defineProperty;var c=Object.getOwnPropertyDescriptor;var h=Object.getOwnPropertyNames;var l=Object.prototype.hasOwnProperty;var T=(o,e)=>{for(var s in e)a(o,s,{get:e[s],enumerable:!0})},S=(o,e,s,t)=>{if(e&&typeof e=="object"||typeof e=="function")for(let r of h(e))!l.call(o,r)&&r!==s&&a(o,r,{get:()=>e[r],enumerable:!(t=c(e,r))||t.enumerable});return o};var y=o=>S(a({},"__esModule",{value:!0}),o);var b={};T(b,{default:()=>k});module.exports=y(b);var n=class extends Set{constructor(){super(...arguments);this.contains=this.has;this.remove=this.delete;this.subtract=this.difference}get elements(){return Array.from(this.keys())}isEmpty(){return this.size===0}isSingleton(){return this.size===1}from(...e){let s=new n;for(let t of e)if(t instanceof n)for(let r of t.keys())s.add(r);else s.add(t);return s}forEach(e,s){for(let t of this.keys())e.call(s,t,t,this)}map(e,s){let t=[];for(let r of this.keys())t.push(e.call(s,r,r,this));return new n(t)}filter(e,s){let t=[];for(let r of this.keys())e.call(s,r,r,this)&&t.push(r);return new n(t)}reduce(e,s){let t=s;for(let r of this.keys())t=e.call(this,t,r,r,this);return t}isSet(e){return e instanceof n||e instanceof Set}clone(){return new n(this.elements)}isSubsetOf(e){for(let s of this.keys())if(!e.has(s))return!1;return!0}isSupersetOf(e){return e.isSubsetOf(this)}isDisjointOf(e){for(let s of this.keys())if(e.has(s))return!1;return!0}isEqualTo(e){return this.size!==e.size?!1:this.isSubsetOf(e)}union(e){return new n(Array.from(this.elements.concat(e.elements)))}intersection(e){let s=[];for(let t of this.keys())e.has(t)&&s.push(t);return new n(s)}difference(e){let s=[];for(let t of this.keys())e.has(t)||s.push(t);return new n(s)}symmetricDifference(e){let s=[];for(let t of this.keys())e.has(t)||s.push(t);for(let t of e.keys())this.has(t)||s.push(t);return new n(s)}complement(e){return e.difference(this)}cartesianProduct(e){let s=[];for(let t of this.keys())for(let r of e.keys())s.push([t,r]);return new n(s)}powerSet(){let e=this.elements,s=[],t=(r,i)=>{if(r===e.length){s.push(i);return}t(r+1,i.concat([e[r]])),t(r+1,i)};return t(0,[]),new n(s.map(r=>new n(r)))}subsets(){return function*s(t,r){for(;r<t.length;){let i=t[r++];for(let f of s(t,r))f.push(i),yield f}yield[]}(this.elements,0)}subsetsCount(){return 2**this.size}},u=n;var k=u;0&&(module.exports={});
