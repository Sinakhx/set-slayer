var n=class extends Set{constructor(){super(...arguments);this.contains=this.has;this.remove=this.delete;this.subtract=this.difference}get elements(){return Array.from(this.keys())}isEmpty(){return this.size===0}isSingleton(){return this.size===1}from(...e){let s=new n;for(let t of e)if(t instanceof n)for(let r of t.keys())s.add(r);else s.add(t);return s}forEach(e,s){for(let t of this.keys())e.call(s,t,t,this)}map(e,s){let t=[];for(let r of this.keys())t.push(e.call(s,r,r,this));return new n(t)}filter(e,s){let t=[];for(let r of this.keys())e.call(s,r,r,this)&&t.push(r);return new n(t)}reduce(e,s){let t=s;for(let r of this.keys())t=e.call(this,t,r,r,this);return t}isSet(e){return e instanceof n||e instanceof Set}clone(){return new n(this.elements)}isSubsetOf(e){for(let s of this.keys())if(!e.has(s))return!1;return!0}isSupersetOf(e){return e.isSubsetOf(this)}isDisjointOf(e){for(let s of this.keys())if(e.has(s))return!1;return!0}isEqualTo(e){return this.size!==e.size?!1:this.isSubsetOf(e)}union(e){return new n(Array.from(this.elements.concat(e.elements)))}intersection(e){let s=[];for(let t of this.keys())e.has(t)&&s.push(t);return new n(s)}difference(e){let s=[];for(let t of this.keys())e.has(t)||s.push(t);return new n(s)}symmetricDifference(e){let s=[];for(let t of this.keys())e.has(t)||s.push(t);for(let t of e.keys())this.has(t)||s.push(t);return new n(s)}complement(e){return e.difference(this)}cartesianProduct(e){let s=[];for(let t of this.keys())for(let r of e.keys())s.push([t,r]);return new n(s)}powerSet(){let e=this.elements,s=[],t=(r,o)=>{if(r===e.length){s.push(o);return}t(r+1,o.concat([e[r]])),t(r+1,o)};return t(0,[]),new n(s.map(r=>new n(r)))}subsets(){return function*s(t,r){for(;r<t.length;){let o=t[r++];for(let i of s(t,r))i.push(o),yield i}yield[]}(this.elements,0)}subsetsCount(){return 2**this.size}},a=n;var l=a;export{l as default};
