var n=class extends Set{constructor(...e){super(...e);this.contains=this.has;this.copy=this.clone;this.remove=this.delete;this.subtract=this.difference;this.relativeComplement=this.difference;if(!!n.autoGlobals)if(!n._globalSet)n._globalSet=new Set(this.elements);else for(let r of e)n._globalSet.add(r)}get globalSet(){return new n(n._globalSet?Array.from(n._globalSet):[])}set globalSet(e){n._globalSet=new Set(e.elements)}static from(...e){let r=new n;for(let t of e)if(Array.isArray(t))for(let s of t)r.add(s);else if(t instanceof n||t instanceof Set)for(let s of t.keys())r.add(s);else r.add(t);return r}get elements(){return Array.from(this.keys())}get cardinality(){return this.size}add(e){return n.autoGlobals&&n._globalSet&&n._globalSet.add(e),super.add(e),this}toArray(){return this.elements}isEmpty(){return this.size===0}isSingleton(){return this.size===1}random(){return this.elements[Math.floor(Math.random()*this.size)]}stringify(e=", "){return`{ ${this.elements.map(t=>t instanceof n?`{ ${t.stringify(e)} }`:JSON.stringify(t)).sort().join(e)} }`}forEach(e,r){for(let t of this.keys())e.call(r,t,t,this)}map(e,r){let t=[];for(let s of this.keys())t.push(e.call(r,s,s,this));return new n(t)}filter(e,r){let t=[];for(let s of this.keys())e.call(r,s,s,this)&&t.push(s);return new n(t)}reduce(e,r){let t=r;for(let s of this.keys())t=e.call(this,t,s,s,this);return t}isSet(e){return e instanceof n||e instanceof Set}clone(){return new n(this.elements)}isSubsetOf(e){for(let r of this.keys())if(!e.has(r))return!1;return!0}isProperSubsetOf(e){return this.size>=e.size?!1:this.isSubsetOf(e)}isSupersetOf(e){return e.isSubsetOf(this)}isProperSupersetOf(e){return this.size<=e.size?!1:this.isSupersetOf(e)}isDisjointOf(e){for(let r of this.keys())if(e.has(r))return!1;return!0}isEqualTo(e){return this.size!==e.size?!1:this.isSubsetOf(e)}union(...e){let r=e.reduce((t,s)=>t.concat(s.elements),this.elements);return new n(r)}intersection(...e){let r=this.elements;for(let t of e){let s=[];for(let o of r)t.has(o)&&s.push(o);r=s}return new n(r)}difference(e){let r=[];for(let t of this.keys())e.has(t)||r.push(t);return new n(r)}symmetricDifference(...e){let r=e.concat(this),t=(s,o)=>{let a=[];for(let i of s.keys())o.has(i)||a.push(i);for(let i of o.keys())s.has(i)||a.push(i);return new n(a)};return r.reduce((s,o)=>t(s,o),new n)}complement(e){let r=this;if(e)return e.difference(this);if(n.autoGlobals&&n._globalSet)r=this.globalSet;else throw new Error(`Global set is not defined: ${e}`);return r.difference(this)}cartesianProduct(e){let r=[];for(let t of this.keys())for(let s of e.keys())r.push([t,s]);return new n(r)}powerSet(){let e=this.elements,r=[],t=(s,o)=>{if(s===e.length){r.push(o);return}t(s+1,o.concat([e[s]])),t(s+1,o)};return t(0,[]),new n(r.map(s=>new n(s)))}subsets(){return function*r(t,s){for(;s<t.length;){let o=t[s++];for(let a of r(t,s))a.push(o),yield a}yield[]}(this.elements,0)}subsetsCount(){return 2**this.size}},S=n;S.autoGlobals=!1;var f=S;var h=f;export{h as default};
