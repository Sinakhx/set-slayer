var n=class extends Set{constructor(){super(...arguments);this.contains=this.has;this.remove=this.delete;this.subtract=this.difference}get elements(){return Array.from(this.keys())}isEmpty(){return this.size===0}isSingleton(){return this.size===1}toArray(){return this.elements}static from(...t){let s=new n;for(let e of t)e instanceof n||e instanceof Set?s.add(Array.from(e)):s.add(e);return s}forEach(t,s){for(let e of this.keys())t.call(s,e,e,this)}map(t,s){let e=[];for(let r of this.keys())e.push(t.call(s,r,r,this));return new n(e)}filter(t,s){let e=[];for(let r of this.keys())t.call(s,r,r,this)&&e.push(r);return new n(e)}reduce(t,s){let e=s;for(let r of this.keys())e=t.call(this,e,r,r,this);return e}isSet(t){return t instanceof n||t instanceof Set}clone(){return new n(this.elements)}isSubsetOf(t){for(let s of this.keys())if(!t.has(s))return!1;return!0}isSupersetOf(t){return t.isSubsetOf(this)}isDisjointOf(t){for(let s of this.keys())if(t.has(s))return!1;return!0}isEqualTo(t){return this.size!==t.size?!1:this.isSubsetOf(t)}union(...t){let s=t.reduce((e,r)=>e.concat(r.elements),this.elements);return new n(s)}intersection(t){let s=[];for(let e of this.keys())t.has(e)&&s.push(e);return new n(s)}difference(t){let s=[];for(let e of this.keys())t.has(e)||s.push(e);return new n(s)}symmetricDifference(t){let s=[];for(let e of this.keys())t.has(e)||s.push(e);for(let e of t.keys())this.has(e)||s.push(e);return new n(s)}complement(t){return t.difference(this)}cartesianProduct(t){let s=[];for(let e of this.keys())for(let r of t.keys())s.push([e,r]);return new n(s)}powerSet(){let t=this.elements,s=[],e=(r,o)=>{if(r===t.length){s.push(o);return}e(r+1,o.concat([t[r]])),e(r+1,o)};return e(0,[]),new n(s.map(r=>new n(r)))}subsets(){return function*s(e,r){for(;r<e.length;){let o=e[r++];for(let i of s(e,r))i.push(o),yield i}yield[]}(this.elements,0)}subsetsCount(){return 2**this.size}},a=n;var l=a;export{l as default};
