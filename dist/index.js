var n=class extends Set{constructor(...e){super(...e);this.contains=this.has;this.remove=this.delete;this.subtract=this.difference;if(!!n.autoGlobals)if(!n._globalSet)n._globalSet=new Set(this.elements);else for(let t of e)n._globalSet.add(t)}get globalSet(){return new n(n._globalSet?Array.from(n._globalSet):[])}set globalSet(e){n._globalSet=new Set(e.elements)}static from(...e){let t=new n;for(let r of e)r instanceof n||r instanceof Set?t.add(Array.from(r)):t.add(r);return t}get elements(){return Array.from(this.keys())}toArray(){return this.elements}isEmpty(){return this.size===0}isSingleton(){return this.size===1}forEach(e,t){for(let r of this.keys())e.call(t,r,r,this)}map(e,t){let r=[];for(let s of this.keys())r.push(e.call(t,s,s,this));return new n(r)}filter(e,t){let r=[];for(let s of this.keys())e.call(t,s,s,this)&&r.push(s);return new n(r)}reduce(e,t){let r=t;for(let s of this.keys())r=e.call(this,r,s,s,this);return r}isSet(e){return e instanceof n||e instanceof Set}clone(){return new n(this.elements)}isSubsetOf(e){for(let t of this.keys())if(!e.has(t))return!1;return!0}isProperSubsetOf(e){return this.size>=e.size?!1:this.isSubsetOf(e)}isSupersetOf(e){return e.isSubsetOf(this)}isProperSupersetOf(e){return this.size<=e.size?!1:this.isSupersetOf(e)}isDisjointOf(e){for(let t of this.keys())if(e.has(t))return!1;return!0}isEqualTo(e){return this.size!==e.size?!1:this.isSubsetOf(e)}union(...e){let t=e.reduce((r,s)=>r.concat(s.elements),this.elements);return new n(t)}intersection(...e){let t=this.elements;for(let r of e){let s=[];for(let o of t)r.has(o)&&s.push(o);t=s}return new n(t)}difference(e){let t=[];for(let r of this.keys())e.has(r)||t.push(r);return new n(t)}symmetricDifference(...e){let t=e.concat(this),r=(s,o)=>{let a=[];for(let S of s.keys())o.has(S)||a.push(S);for(let S of o.keys())s.has(S)||a.push(S);return new n(a)};return t.reduce((s,o)=>r(s,o),this)}complement(e){let t=this;return!e&&n.autoGlobals&&(t=this.globalSet),t.difference(this)}relativeComplement(e){return e.difference(this)}cartesianProduct(e){let t=[];for(let r of this.keys())for(let s of e.keys())t.push([r,s]);return new n(t)}powerSet(){let e=this.elements,t=[],r=(s,o)=>{if(s===e.length){t.push(o);return}r(s+1,o.concat([e[s]])),r(s+1,o)};return r(0,[]),new n(t.map(s=>new n(s)))}subsets(){return function*t(r,s){for(;s<r.length;){let o=r[s++];for(let a of t(r,s))a.push(o),yield a}yield[]}(this.elements,0)}subsetsCount(){return 2**this.size}},i=n;i.autoGlobals=!1;var l=i;var h=l;export{h as default};
